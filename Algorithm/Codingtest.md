# 알고리즘 연습
> Do it ! 알고리즘 코딩테스트 with JAVA 책의 이론을 습득하고 실습하였습니다.

<br>

## 💡 순서
```java
- 핵심 이론 알아보기
- 문제 분석하기 
    - 어떤 알고리즘을 사용할지의 전략
- 손으로 전략세기
- 슈도코드로 구체화
- 코드 작성 : 리뷰
```


### 코딩테스트 준비하기
>시간복잡도 유형<br>
> 빅-오메가 : 최선일때의 연산횟수를 _나타낸 표기법<br>
> 빅-세타 : 보통일때의 연산횟수를 나타낸 표기법<br>
> 빅-오 : 최악일때의 연산횟수를 나타낸 표기법<br>
- 시간복잡도에 따른 적절한 알고리즘 선택 <br>
  → 코딩테스트에서는 빅-오표기법(O(n))을 기준으로 수행 시간을 계산하는 것이 좋다.

### 시간 복잡도 활용하기
> 알고리즘 선택의 기준으로 사용하기<br>
- 연산 횟수는 **1초에 1억 번** 연산하는 것을 기준으로 생각합니다. 
- 시간 복잡도는 항상 최악일 때, 즉 데이터의 크기가 가장 클 때를 기준으로 합니다.
> 💡 해당 내용을 바탕으로 문제에서 주어진 시간 제한과 데이터 크기를 바탕으로 어떤 정렬 알고리즘을 사용해야 할것인지 파악할수 있습니다.<br>
> 연산 횟수 = 알고리즘 시간 복잡도 * 데이터 크기<br>
> ex) 병합 nlogn(2000만번)-적합, 버블 n^2(10억번)-부적합, 2초이내(2억번)
> 

### 시간 복잡도를 바탕으로 코드 로직 개선
```java
시간복잡도 도출기준
1. 상수는 시간 복잡도 계산에서 제외한다.
2. 가장 많이 중첩된 반복문의 수행 횟수가 시간 복잡도의 기준이 된다.
```
- 연산 횟수가 N인 경우
```java
int N = 10000;
int cnt = 0;
for (int i = 0; i< N; i++){
    System.out.println("연산 횟수:" + cnt++);
        }

```
- 연산 횟수가 3N인 경우
```java
int N = 10000;
int cnt = 0;
for (int i = 0; i< N; i++){
    System.out.println("연산 횟수:" + cnt++);
        }
for (int i = 0; i< N; i++){
    System.out.println("연산 횟수:" + cnt++);
        }
for (int i = 0; i< N; i++){
    System.out.println("연산 횟수:" + cnt++);
        }
```

> 연산 횟수는 3배가 차이나고 코딩 테스트에서는 상수를 무시하므로 두 코드 모든 시간 복잡도는 O(n)
- 연산 횟수가 N^2인 경우
```java
int N = 10000;
int cnt = 0;
for (int i = 0; i< N; i++){
    for (int j = 0; j<N; j++){
        System.out.println("연산 횟수:" + cnt++);
    }
}
```

### 디버깅
> 프로그램에서 발생하는 문법 오류나 논리 오류를 찾아 바로잡는 과정을 디버깅이라고 합니다.<br>
> 문법 오류는 컴파일러가 자동으로 찾아주므로 테스트할때 문제가 되지않습니다. 논리오류는 코드가 사용자의 의도와
> 다르게 동작하는 것이며 다양한 형태로 발생합니다.
- 디버깅하는법
```java
1. 코드에서 디버깅하고자하는줄에 중단점을 설정한다. 이때 중단점을 여러 개 설정할 수 있다.
2. IDE의 디버깅 기능을 실행하면 코드를 1줄씩 실행하거나 다음 중단점까지 실행할 수 있으며,
   이 과정에서 추적할 변숫값도 지정할 수 있다. 이 방법으로 변숫값이 자신이 의도하는 대로 바뀌는지 확인
3. 변숫값 이외에도 원하는 수식을 입력해 논리 오류를 파악할 수 있다.
```
> 자료형은 처음부터 long형으로 선언하자!

