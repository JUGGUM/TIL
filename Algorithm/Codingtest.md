# 알고리즘 연습
> Do it ! 알고리즘 코딩테스트 with JAVA 책의 이론을 습득하고 실습하였습니다.

<br>

## 💡 순서
```java
- 핵심 이론 알아보기
- 문제 분석하기 
    - 어떤 알고리즘을 사용할지의 전략
- 손으로 전략세기
- 슈도코드로 구체화
- 코드 작성 : 리뷰
```


### 코딩테스트 준비하기
>시간복잡도 유형<br>
> 빅-오메가 : 최선일때의 연산횟수를 _나타낸 표기법<br>
> 빅-세타 : 보통일때의 연산횟수를 나타낸 표기법<br>
> 빅-오 : 최악일때의 연산횟수를 나타낸 표기법<br>
- 시간복잡도에 따른 적절한 알고리즘 선택 <br>
  → 코딩테스트에서는 빅-오표기법(O(n))을 기준으로 수행 시간을 계산하는 것이 좋다.

### 시간 복잡도 활용하기
> 알고리즘 선택의 기준으로 사용하기<br>
- 연산 횟수는 **1초에 1억 번** 연산하는 것을 기준으로 생각합니다. 
- 시간 복잡도는 항상 최악일 때, 즉 데이터의 크기가 가장 클 때를 기준으로 합니다.
> 💡 해당 내용을 바탕으로 문제에서 주어진 시간 제한과 데이터 크기를 바탕으로 어떤 정렬 알고리즘을 사용해야 할것인지 파악할수 있습니다.<br>
> 연산 횟수 = 알고리즘 시간 복잡도 * 데이터 크기<br>
> ex) 병합 nlogn(2000만번)-적합, 버블 n^2(10억번)-부적합, 2초이내(2억번)
> 

### 시간 복잡도를 바탕으로 코드 로직 개선
```java
시간복잡도 도출기준
1. 상수는 시간 복잡도 계산에서 제외한다.
2. 가장 많이 중첩된 반복문의 수행 횟수가 시간 복잡도의 기준이 된다.
```
- 연산 횟수가 N인 경우
```java
int N = 10000;
int cnt = 0;
for (int i = 0; i< N; i++){
    System.out.println("연산 횟수:" + cnt++);
        }

```
- 연산 횟수가 3N인 경우
```java
int N = 10000;
int cnt = 0;
for (int i = 0; i< N; i++){
    System.out.println("연산 횟수:" + cnt++);
        }
for (int i = 0; i< N; i++){
    System.out.println("연산 횟수:" + cnt++);
        }
for (int i = 0; i< N; i++){
    System.out.println("연산 횟수:" + cnt++);
        }
```

> 연산 횟수는 3배가 차이나고 코딩 테스트에서는 상수를 무시하므로 두 코드 모든 시간 복잡도는 O(n)
- 연산 횟수가 N^2인 경우
```java
int N = 10000;
int cnt = 0;
for (int i = 0; i< N; i++){
    for (int j = 0; j<N; j++){
        System.out.println("연산 횟수:" + cnt++);
    }
}
```

